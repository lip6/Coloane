package fr.lip6.move.coloane.extension.exportToDOT;

import org.eclipse.core.runtime.IProgressMonitor;

import fr.lip6.move.coloane.interfaces.model.IArc;
import fr.lip6.move.coloane.interfaces.model.IAttribute;
import fr.lip6.move.coloane.interfaces.model.IElement;
import fr.lip6.move.coloane.interfaces.model.IGraph;
import fr.lip6.move.coloane.interfaces.model.INode;

public class DotConverter {

	public static String translateModel(IGraph model, IProgressMonitor monitor) {
		StringBuffer res = new StringBuffer();

		// Entête du fichier DOT
		res.append("/*                                         */\n");
		res.append("/* This file has been generated by Coloane */\n");
		res.append("/* http://coloane.lip6.fr/                 */\n");
		res.append("/*                                         */\n");

		res.append("digraph G {\n");

		// Parcours des noeuds
		res.append(translateNodes(model, monitor));

		// Parcours des arcs
		res.append(translateArcs(model, monitor));

		// Pied du fichier DOT
		res.append("}");
		return res.toString();
	}

	/**
	 * Traduction de tous les noeuds du modèle en format DOT
	 * @param model Le modèle qui contient les noeuds à traduire
	 * @param monitor 
	 * @return Une chaine de caractères DOT
	 */
	private static String translateNodes(IGraph model, IProgressMonitor monitor) {
		StringBuffer nodes = new StringBuffer();

		// Parcours de tous les noeuds du modèle
		monitor.subTask("Export nodes");
		for (INode node : model.getNodes()) {
			
			// Dans le cas d'une place
			if ("place".equals(node.getNodeFormalism().getName())) {
				nodes.append("\t " + node.getId() + " [label=\"\", shape=ellipse];\n");
			
			// Dans le cas d'une transition
			} else if ("transition".equals(node.getNodeFormalism().getName())) {
				nodes.append("\t " + node.getId() + " [label=\"\", shape=rectangle];\n");
			
			// Dans tous les autres cas, on ne traite pas...
			} else {
				continue;
			}
			
			// Traitement des attributs
			nodes.append(translateAttributes(node));

			monitor.worked(1);
		}
		return nodes.toString();
	}

	/**
	 * Traduction de tous les arcs du modèle en format DOT
	 * @param model Le modèle qui contient les arcs à traduire
	 * @param monitor 
	 * @return Une chaine de caractères DOT
	 */
	private static String translateArcs(IGraph model, IProgressMonitor monitor) {
		StringBuffer arcs = new StringBuffer();
		
		// Parcours de tous les arcs du modèle
		monitor.subTask("Export arcs");
		for (IArc arc : model.getArcs()) {
			// Dans le cas d'un arc simple
			if ("arc".equals(arc.getArcFormalism().getName())) {
				arcs.append("\t " + arc.getSource().getId() + " -> " + arc.getTarget().getId() + "");
				arcs.append(" [label=\"" + arc.getAttribute("valuation").getValue() + "\"];\n");
				
			// Dans tous les autres cas, on ne traite pas
			} else {
				continue;
			}

			monitor.worked(1);
		}
		return arcs.toString();
	}

	/**
	 * Traduction de tous les attributs d'un élément
	 * @param element L'élément dont les attributs doivent être traduits
	 * @return Une chaine de caractères DOT
	 */
	private static String translateAttributes(IElement element) {
		StringBuffer attributes = new StringBuffer();
		attributes.append("\t\t /* Les attributs de " + element.getId() + "*/\n");
		for (IAttribute attribut : element.getAttributes()) {
			if (attribut.getValue().equals(attribut.getAttributeFormalism().getDefaultValue())) {
				continue;
			}
			attributes.append("\t\t \"" + element.getId() + "-" + attribut.getName() + "\"");
			attributes.append(" [label=\"" + attribut.getValue() + "\", shape=plaintext, fontcolor=blue];\n");
			attributes.append("\t\t \"" + element.getId() + "-" + attribut.getName() + "\" -> \"" + element.getId() + "\"");
			attributes.append(" [color=blue, style=dotted];\n");
		}
		return attributes.toString();
	}


}
