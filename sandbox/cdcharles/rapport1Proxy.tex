\documentclass{article}

\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}


\title{Rapport : Proxy}
\author{Dimitri Charles}
\date{20 juin 2007}


\begin{document}

\section{Introduction}
\indent
	L'objectif est de faire dialoguer Coloane et FrameKit via un proxy local, cod\'e en java, ce dernier se trouvant sur le localhost. Coloane se connecte sur le port 80 du proxy \'a l'adressse 127.0.0.1 et ce dernier \'ecoute les r\'eponses de FrameKit sur le port 7001 \'a l'adresse 132.227.64.27.Pour lancer le programme appel\'e MainProxy, il suffit de taper la commande: \\\emph{java MainProxy AdresseServeurDistant portServeurDistant}.
\\
	Par exemple, pour tester notre page avec google, on tape \emph{java MainProxy www.google.fr 80}. Puis, dans le navigateur de son choix (Firefox, Konqueror), tapez \emph{http://localhost:8080}. Pour visualiser le r\'esultat, il est important d'avoir un serveur local (localhost). Donc, il serait int\'eressant d'avoir install\'e pr\'ealablement Apache ou sinon t\'el\'echargez le \'a l'adresse \emph{http://httpd.apache.org/download.cgi}.
\\
\\
\section{Organisation des classes}
	Ce programme comprend 2 classes. La classe principale, MainProxy, qui prend 2 param\`etres : l'adresse du serveur distant (soit sous forme d'URL soit l'adresse IP) et son port. Une classe, TraitemenIO qui contient le code des Threads pour la communication entre les sockets du client et du serveur distant. Les principaux packages utilis\'es dans ce programme sont : \emph{java.lang.Thread, java.net.Socket, java.net.ServerSocket, java.net.InetSocketAddress,java.io.*}.
\\
	Dans la classe MainProxy, on  d\'eclare  la socket du client de type Socket et la socket du proxy qui est de type ServerSocket. Vu qu'on connait l'adresse et le port du proxy("localhost" et 8080), on commence par l'initialiser. On r\'ecup\`ere l'adresse du serveur distant et son port en paramètres. Et dans une boucle infinie, on l'initialise et le serveur attend un client. A l'arriv\'ee de ce dernier, les \'echanges sont assur\'ees par la classe TraitementIO.
\\
	Dans cette classe, on d\'eclare 2 sockets (client et serveur) et on r\'ecup\`ere leurs flux d'entr\'ee et de sortie. On d\'eclare aussi un tableau d'octets dans lequel on va transmettre les messages. Etant donn\'e que cette classe h\'erite de Thread, elle r\'ed\'efinit la méthode \textbf{run()}. Tant que la socket du client et la socket du serveur sont connect\'ees, le client lit un flux d'octets sur son entr\'ee standard et les envoie au serveur. Le serveur lit ces donn\'ees et les renvoie au client. En cas d'erreur, une IOException est lev\'ee et on sort de la boucle. On ferme les flux et les sockets.  
\\	
\\
\section{Conclusion}
	Cette mani\`ere de concevoir ne marche pas \'a tous les coups. Par exemple, en testant le proxy sur www.google.fr sur le port 80, tous les \'el\'ements sont charg\'es sauf le logo GOOGLE. Sur Coloane, on peut s'attendre à diff\'erents types de comportement. Quand on rentre un mauvais mot de passe(apr\`es avoir rentr\'e les coordonn\'ees du proxy), Framekit r\'epond que l'authenfication a \'echou\'e mais quand on rentre le bon, FrameKit est muet.
Pour corriger ce probl\'eme, il faudra s'assurer que le client se connecte au proxy et que les \'echanges entre le client et le serveur soient r\'eellement faits. Autre solution, il serait \'egalement int\'eressant de connaitre le protocole de communication de FrameKit.




\end{document}
