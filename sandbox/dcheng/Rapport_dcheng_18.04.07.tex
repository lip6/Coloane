\documentclass{article}

\usepackage[francais]{babel}

\title{Rapport: Diagramme de classe du meta-mod\`ele}
\author{David Cheng}
\date{18 Avril 2007}

\begin{document}
\maketitle
\section{Demarches}
\indent
Afin de pouvoir r\'ealiser les diagrammes et montrer les d\'ependances entre les paquetages et les classes, j'ai regroup\'e l'ensemble des paquetages utilesau mod\`ele dans un seul projet.
La mod\`elisation du mod\`ele a \'et\'e r\'ealis\'e \`a l'aide d'Omondo, un plugin Eclipse.


\section{Diagrammes de classe}
\subsection{Liste des diagrammes}

Gr\^ace à l'utilisation d'Omondo, j'ai pu r\'ealiser l'ensemble des diagrammes suivants:

\begin{itemize}
\item[1] Diagramme de classe repr\'esentant les d\'ependances entre les paquetages ainsi que l'h\'eritage

\textit{Model\_Inheritance.jpeg}

\item[2] Diagramme de classe repr\'esentant les d\'ependances entre les diff\'erentes classes du projet

\textit{Model\_Dependencies.jpeg}

\item[3] Diagramme de classe représentant les associations
entre les différentes classes du paquetage "interfaces.model"
ainsi que une possibilité d'implémentation d'un modèle dans un noeud

\textit{Model\_Associations\_ListOfModel.jpg}

\item[4] Diagramme de classe repr\'esentant les associations(compositions et aggrégations) 
entre les différentes classes du paquetage "interfaces.model"
ainsi que une possibilité d'implémentation d'un modèle dans un noeud

\textit{Model\_Association.Compositions\_Classes\_View.jpg}
\end{itemize}


\subsection{D\'ependances}

La repr\'esentation des diagrammes permet de visualiser les d\'ependances entre les diff\'erents paquetages et classes.

On peut en d\'eduire que le paquetage interfaces est ind\`ependant des paquetages api et coloane mais pas r\'eciproquement.

En effet, les classes au sein des paquetages api.model et coloane.model héritent des classes abstraites du paquetages interfaces.model.
Elles doivent donc d\'efinir les m\'ethodes abstraites des classes dont elles h\'eritent.



\subsection{Association, aggr\'egation ou composition}

Le diagramme 4 montre que l'ensemble des associations sont des compositions hormis ListOfModel (cf. section 2.4).

En effet, un arc ne peut exister sans un noeud et un noeud sans un mod\`ele.
De m\^eme, un attribut d\'epend d'un arc, d'un noeud ou d'un mod\`ele.


\section{Le code}
\subsection{Possibilit\'e d'impl\'ementation}

Les diagrammes 3 et 4 montrent une possibilit\'e d'impl\'ementer un mod\`ele dans un noeud.

L'attribut "listOfModel" de la classe Node permet de lier un ou plusieurs mod\`ele \`a un noeud.
Le mod\`ele sera ind\'ependant du noeud auquel il est affect\'e, d'o\`u l'aggr\'egation.	

Les m\'ethodes *ListOfModel* de la classe Node, pr\'esentes sur le diagramme ont \'et\'e g\'en\'er\'ees automatiquement par Omondo mais ne sont pas pr\'esentes dans le code d'origine.



\subsection{ListOfArc: Attribut inutile?}

Le diagramme 3 (ou 4) montre que l'attribut "listOfArc" de la classe model peut sembler \^etre redondant vis-\`a-vis de ListOfOuputArc et ListOfInputArc de la classe Node.

Cependant, ListOfArc permet un parcours plus rapide de l'ensemble des arcs du mod\`ele car l'utilisation de ListOfOutputArc et ListOfInputArc implique dans le pire cas un parcours des 2 listes de chaque noeud du mod\`ele.

\subsection{Code mort}

La m\'ethode getMaxId de la classe Model (paquetage interface) ne semble pas \^etre utilis\'ee.

Cependant, elle peut s'av\'erer \^etre utile dans la r\'éalisation de tests de untaire v\'erifiant l'unicit\'e des identifiants.


\end{document}
