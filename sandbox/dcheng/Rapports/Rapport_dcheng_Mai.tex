\documentclass{article}

\usepackage[francais]{babel}

\title{Rapport: Refactoring du mod\`ele et tests unitaires}
\author{David Cheng}
\date{01 Juin 2007}

\begin{document}
\maketitle
\section{D\'emarches}

La classe TestModel regroupe l'ensemble des tests unitaires d'ajouts et de suppressions d'arcs,d'ajout de noeuds, d'unicit\'e des identifiants, 
d'ajout d'un attribut et du translate/buildmodel.\\

Ces tests ont \'et\'e regroup\'es au sein d'un m\^eme sc\'enario afin de simuler au mieux les actions d'un utilisateur.
A la suite de ces tests, des modifications du meta-meta model sont apport\'ees afin d'ajouter 
de nouvelles fonctionnalit\'es, de simplifier ou de corriger le code.


\section{Sc\'enario}
\subsection{Ajout d'un arc}

L'ajout d'un arc peut \^etre possible ou non.\\

Il y'a donc 2 types d'ajout \`a traiter:

L'ajout de l'arc est r\'ealisable (sans prendre en compte le mod\`ele).

L'ajout de l'arc n'est pas r\'ealisable dans tous les cas.\\

Deux m\'ethodes permettent de differencier ces cas, void switchArcOk et void switchArcNull:\\

void switchArcOk:

\begin{itemize}
\item Ajout de deux noeuds au mod\`ele et d'un arc qui relie ces noeuds.

\item Ajout d'un arc et d'un noeud source au mod\`ele, le noeud cible \'etant 
choisi al\'eatoirement parmi les noeuds d\'ej\`a pr\'esent dans le mod\`ele.

\item Ajout d'un arc et d'un noeud cible au mod\`ele, le noeud source \'etant 
choisi al\'eatoirement parmi les noeuds d\'ej\`a pr\'esent dans le mod\`ele.

\item Ajout d'un arc dont noeuds source et cible sont choisis al\'eatoirement 
parmi les noeuds d\'ej\`a pr\'esent dans le mod\`ele.\\
\end{itemize}

void switchArcNull:

\begin{itemize}
\item Ajout d'un arc dont les noeuds source et cible existent mais ne sont pr\'esent dans le mod\`ele.

\item Ajout d'un arc dont le noeud source n'est pas pr\'esent dans le mod\`ele.

\item Ajout d'un arc dont le noeud cible n'est pas pr\'esent dans le mod\`ele.\\

\end{itemize}

A l'ajout d'un arc, il faut v\'erifier que l'arc a un noeud cible et un noeud source pr\'esents dans le mod\`ele.
Les listes d'arc tel que Model.listOfArc,
Node.listOfInputArc et Node.ListOfOutputArc doivent \^etre mises \`a jour, c'est-\`a-dire,
qu'elles doivent contenir l'identifiant unique de l'arc ajout\'e.

\subsection{Suppression d'un arc}

A la suppression d'un arc, les listes d'arc tel que Model.listOfArc,\\
Node.listOfInputArc et Node.listOfOutputArc doivent \^etre mises \`a jour.
Elles ne doivent plus contenir l'identifiant unique de l'arc supprim\'e.

\subsection{Suppression d'un noeud}

A la suppression d'un noeud, les listes d'arc tel que Model.listOfArc du mod\`ele ,
Node.listOfInputArc et Node.listOfOutputArc des noeuds voisins
doivent \^etre mises \`a jour.\\

Si les arcs du noeud \`a supprimer sont "entrant" alors les noeuds dont ces arcs 
sont "sortant" doivent mettre \`a jour leur liste "listOfOutputArc".\\

Respectivement, si les arcs du noeud \`a supprimer sont "sortant" 
alors les noeuds dont ces arcs sont "entrant" doivent mettre \`a jour leur liste "listOfInputArc".

\subsection{Ajout d'un attribut}

Un attribut est ajout\'e \`a chaque ajout d'arc.
Cet attribut est ajout\'e al\'eatoirement au mod'\`ele, \`a un arc ou \`a une noeud. 


\subsection{Sc\'enario}

Le sc\'enario est donc le suivant:\\

Le nombre de tour est fix\'e par la variable "max\_tour".
Le nombre d'arc \`a supprimer est fix\'e par la variable "nb\_remove".\\

Al\'eatoirement, on ajoute un arc de fa\c{c}on correcte ou non au mod\`ele \`a chaque tour sauf au tour 
o\`u l'on supprime nb\_remove arcs ou un noeud.
Si un arc est ajout\'e alors un attribut est ajout\'e soit au mod\`ele, soit \`a un noeud, soit \`a un arc.\\

Tous les 8 tours, nb\_remove arcs sont choisis al\'eatoirement puis supprim\'es.
Une comparaison des sorties des m\'ethodes translate() avant et apr\`es la ou les suppressions 
est faites.

Tous les 10 tours,les tests sur les m\'ethodes translate() et buildModel() sont effectu\'e.

Tous les 15 tours, si le tours n'est pas un tour de suppression d'arc alors un noeud choisi al\'etoirement est supprim\'e du mod\`ele.



\section{Les m\'ethodes translate() et buildModel()}

Afin de tester les m\'ethodes translate() et buildModel(), deux tests sont effectu\'es.\\

Le premier consiste \`a effectuer un translate() sur le mod\`ele courant et de le comparer 
au mod\`ele obtenu en faisant appel \`a buildModel() prenant en param\`etre
la sortie du translate pr\'ecedemment effectu\'e.\\

Le second consiste \`a comparer la sortie de l'appel de la m\'ethode translate() sur deux mod\`ele diff\'erents.
Des tests sont aussi effectu\'es sur les m\'ethodes translate() de Arc et Node.


\subsection{M\'ethode de comparaison}
Une m\'ethode compareTab(String[] t1, String[] t2) a \'et\'e cr\'e\'ee
afin de comparer les tableaux de String obtenues apr\`es un translate.\\

Elle v\'erifie si les tableaux t1 et t2 sont de m\^eme taille, 
si oui elle verifie que chaque ligne du tableau t1 se trouve dans le tableau t2. 
Si tel est le cas compareTab() renvoie true, false sinon.

\subsection{Tests sur le mod\`ele}
Soient T1, T2, deux tableaux de String et M une instance de type Model.\\

Tous les 10 tours de boucle, on effectue une translate du mod\`ele courant qu'on stocke dans T1.
A partir de T1, on cr\'ee un nouveau mod\`ele M \`a l'aide de la m\'ethode buildModel 
(dans le constructeur de la classe Model).
On effectue un translate sur M qu'on stocke dans T2.

On peut alors comparer T1 et T2 en v\'erifiant qu'elles contiennent les m\^emes lignes.\\

A chaque tour de suppression d'un arc, la traduction du mod\`ele en CAMI est stock\'e 
dans T1 avant suppression et dans T2 apr\`es suppression.
Les deux tableaux sont alors compar\'e et doivent \^etre diff\'erents.

\subsection{Tests sur les noeud et les arcs}
Tous les 10 tours,\`a partir de la liste des identifiants, 
on teste si tous les noeuds et arcs du mod\`ele courant et du mod\`ele M
\textit{(cf. Tests sur les mod\`ele)} ayant le m\^eme identifiant, ont une traduction en CAMI identique.\\

On teste ensuite si un noeud (resp. arc) a bien une traduction en CAMI diff\'erente
d'un noeud (resp. arc) ayant un identifiant diff\'erent.



\section{Refactoring du meta-meta model}

A la suite des diff\'erents tests unitaires, des modifications et des ajouts ont \'et\'e apport\'ees aux paquetages interfaces.model et coloane.model.

\subsection{Interfaces}

\begin{itemize}
	\item[Model]
		:
		\begin{itemize}
			\item Modification de addArc(), l'ajout d'un arc, dont un des noeuds cible ou source
			n'est pas pr\'esent dans le mod\`ele, n'est plus possible.
			\item Ajout d'un vecteur listOfId afin de tester l'unicit\'e des identifiants
			\item L'attribution des identifiants ne se fait plus avec maxId mais getMaxId()
			afin d'\^etre sur d'obtenir l'identifiant maximum des \'el\'ements pr\'esents dans le mod\`ele.
		\end{itemize}

	\item[Node]
		:
		\begin{itemize}
			\item addAttribute(IAttribute attribute): Si la valeur de l'attribut n'est pas vide 
			alors on modifie le refId de celui-ci en lui affectant l'id du noeud auquel il est ajout\'e. 
			\item Ajout des getter et setter pour listOfInputArc et listOfOutputArc.
		\end{itemize}

	\item[Arc]
		:
		\begin{itemize}
			\item addAttribute(IAttribute attribute): Si la valeur de l'attribut n'est pas vide 
			alors on modifie le refId de celui-ci en lui affectant l'id de l'arc auquel il est ajout\'e. 
		\end{itemize}

	\item[Attribute]
		:
		\begin{itemize}
			\item Constructeur: prend en entr\'ee (String name, String value, int refId) et non plus un tableau de String pour valeur de l'attribut.
			\item Modification de setValue() et getValue, simplifi\'ees \`a de simple getter et setter. 
		\end{itemize}
	

\end{itemize}




\subsection{Coloane}
\begin{itemize}
	\item[Model]
		:
		\begin{itemize}
			\item Modification de buildModel() afin de suivre les modifications apport\'ees \`a interfaces.model.Attribute.
			Prise en compte du nodeType du mod\`ele (setFormalism()).
			\item Modification de translate() car les param\`etres du mod\`ele n'\'etaient pas traduits en CAMI.
		\end{itemize}

	\item[Attribute]
		:
		\begin{itemize}
			\item Modification de translate(): la traduction du mod\`ele en CAMI ce fait \`a partir d'une String et plus d'un tableau de String.
		\end{itemize}
\end{itemize}
	

\section{Conclusion}
Le meta-meta model a \'et\'e modifi\'e afin de le simplifi\'e et qu'il soit d'avantage ind\'ependant de l'API.\\

Les attributs multilignes ne sont plus sous forme tableau mais d'une cha\^ine de caract\`eres 
qu'il faudra traiter hors du meta-meta model.
Ainsi, suivant l'API, il n'y aura pas \`a modifier le meta-meta model car la traduction sera \'etudi\'e
Ã  l'impl\'ementation de la m\'ethode abstraite translate().


\end{document}

