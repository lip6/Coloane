\documentclass{article}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}

%\usepackage[latin1]{inputenc}

%%\usepackage[T1]{fontenc}
%%\usepackage[french]{babel}

%%%\usepackage[francais]{babel}
%%%\usepackage[T1]{fontenc}
%%%\usepackage[latin1]{inputenc}

%%%%\usepackage[T1]{fontenc}
%%%%\usepackage[frenchb]{babel}

\title{Rapport de stage - Coloane}
\date{Janvier 2008}
\author{Monir CHAOUKI}

\begin{document}

\maketitle

\begin{quotation}
\textit{
Le but de mon stage est, la concéption d'un point d'extension, et la réalisation 
d'une extension pour Coloane. La concéption de points d'extensions, permettra à 
Coloane, d'intégrer de nouvelles fonctionalités, via les contributions 
d'autres développeurs (en respectant certaines conditions), sans que ceux--ci,
 est à modifier le code de Coloane.}
\end{quotation}

\newpage

\section{Notions impotrtantes}
Nous allons présenter quelques notions, avant de passer à la présentation de 
Coloane, et aux mécanismes mis en jeu pour la conception et à la réalisation 
d'un point d'extension.

\subsection{Plugin}
Un plugin, est un programme qui s'ajoute à une application principale, pour lui 
offrire de nouvelles fonctionnalités. Il existe plusieurs applications qui 
proposent d'ajouter des plugins. Par exemples, le navigateur internet 
"Mozilla FireFox", propose plusieurs plugins allant du simple traducteur, aux 
lecteur de MP3 intégré au navigateur. Tous ces plugins sont issus des 
contributions de developpeurs.

\subsection{Extensions}
Une extension peut être vue comme un plugin limité. En faite, une extension, 
permet d'ajouter de nouveaux services, à une fonctionnalité déjà présente dans 
une application. Reprenons notre précédent exemple sur le navigateur internet 
"Mozilla FireFox". Comme il a été dit plus haut, "Mozilla FireFox" proposent 
des plugins qui permettent de traduire des pages, dans une langue spécifique. 
Il est possible, si les plugins le permettent, d'ajouter de nouvelle langue au 
traducteur, via les contributions d'autres developpeurs, si ceux--ci developpent 
un extensions qui s'ajoute aux plugins existant.

\subsection{Points d'extensions}
Nous avons vue, qu'une extension, est un service qui venai s'ajouter aux 
fonctionnalités, d'une application (ou d'un plugin). Pour qu'une extension 
puisse s'ajoute à une application (ou à un plugin), il faut que celle--ci 
déclare un point d'extension. La déclaration de points d'extensions, permet 
ainssi, à une application d'être extensible, et d'offrire de nouveaux services, 
venant d'autres contributions. Donc, un point d'extension, permet d'indiquer, 
aux extensions où elle doivent venire se greffer, pour qu'elle puisse enrichire 
une application (ou un plugin).

\newpage

\section{Coloane}

\subsection{Presentation de Coloane}
Coloane est un plugin, pour Eclipse, qui permet de modéliser, les réseaux de 
Petri. L'une de ses philosophies est d'être multi--platforme. Le moteur 
physique, utilise un format non standard, le CAMI, pour travailler, sur ces 
réseaux de Petri. 

\subsection{Evolutions de Coloane}
L'une des évolutions trés impotrantes, à mettre en place pour Coloane, c'est 
d'offrire la possiblité d'utilsier différents formats de représentations de 
réseau de Petri, permettant ainssi l'échange de différents formats de fichiers.

En effet, aujourd'hui, l'inconveniant majeur de Coloane commme nous l'avons 
écrit plus haut, c'est qu'il n'utilisent qu'un format, non standardiser le: 
CAMI. Or, il existe plusieurs formats pour la représentation des réseaux de 
Petri, dont un principale en cours de normalisation le: PNML.

\subsection{Limites liés aux l'evolutions de Coloane}
Aujourd'hui, il est biensûre possible de faire évoluer Coloane, mais cela 
implique d'entrer à l'intèrieur du code, et de le modifier directement pour 
ajouter les évolutions voulus.

Or, le fait d'entrer dans le code, de Coloane, qui est actuelement stable, est 
un facteur important d'apparition de bugs. De plus, si plusieurs développeurs 
souhaitent contribuer au projet Coloane pour le faire évoluer, le code risque 
vite d'être confus, sans régles etablies.

Il serait donc, intéresant de pouvoire faire évoluer Coloane, sans toucher 
au code. Le fait de faire évoluer Coloane correspondrait, à ajouter de 
nouvelles fonctionnalitées ou de nouveaux services. Or, ajouter des 
fonctionnalitées ou services, c'est ajouter un plugin ou une extension.

Par conséquant, si l'on veut faire evoluer Coloane, il faudrait 
songer à utiliser des plugins qui se mettent à coter de lui, ou des extensions 
qui viennent se greffer à lui.

\newpage

\section{Convértiseur de format de représentations de Réseau de Petri}
Nous avons vue précedement, que l'une des évolutions importantes pour 
Coloane, à mettre en place, est un convértiseur de format de représentations de 
Réseau de Petri, permettant ainssi à Coloane d'importer et exporter différents 
formats dont, le plus importants le: PNML.

\subsection{Solutitions envisagées}
Comme nous l'avons écris, deux solutions sont envisagales pour permettre à 
Coloane d'integré de nouvelle fonctionnalités et d'être évolutif (i.e. intégrer 
de nouveaux formats): un plugin ou un point d'extension.

\subsubsection{le plugin}
Dans le cas d'un plugin, Coloane, n'aura aucune mettrise au niveau de 
l'intérface graphique qui permet d'intéragir avec l'utlisateur pour 
l'importations et l'exportations de nouveaux format . Toutes les contributions 
pourrons gérer l'intérface graphique,et implementer les fonctions d'importations 
et d'exportations de nouveaux format, comme bon leurs semblent.

\subsubsection{le point d'extension}
Dans le cas d'un point d'extension, Coloane gérera toujours l'intérface 
graphique, mais délèguera aux extensions qui viendront se greffer sur ce point, 
seulement, les fonctions d'importations et d'exportations de nouveaux formats et 
ceux--ci devrons respecter certaines régles.

\subsection{Solutions choisies}
Il est bien évident que nous allons choisir d'utiliser un point d'extension dans 
Coloane pour que l'on est un certaines maîtrise, des contributions qui permetteront 
de faire des importations et des exportations de nouveaux format.

En effet, chaque contributions devrons avoir la même intérace graphique pour 
interagire avec l'utilisateur, pour que celui--ci, ne soit pas perturber 
lorsqu'il veut exporter ou importer dans des formats diffférent. De plus, on 
imposera aux contributions de respecter certaines régles qui est en faites: 
une intérfaces à implementer.

Ainssi toutes nouvelles contributions offrants de nouveaux format n'aura qu' à 
offrire ses service en utilisant le point d'extension définie par Coloane.


\newpage

\section{Concéption de points d'extensions}
Nous allons utiliser des points d'extensions, comme nous l'avons expliqués précedement, 
pour permettre aux contributions d'offrire leur services d'importations et 
d'exportations. Utiliser des points d'extensions impliquent de préparer Coloane. Pour cela, 
il faut ajouter quelques lignes dans le fichier \textbf{plugin.xml} pour définire les points 
d'extensions, créer les fichiers \textbf{imports.exsd} et \textbf{imports.exsd } dans un 
repertoire \textbf{schema/} qui définissent la grammaire des points d'extensions, et 
modifier le fichier \textbf{MANIFEST.MF} pour lui spécifier les packages à exporter et 
qui sont sucéptibles d'être utilisés par les extensions.

Une remarque importante, Eclipse offre une intérface graphique trés agréable : 
PDE (Plug-ins Development Environment), qui permet  la concéption et la definition de points d'extensions sont 
diffuclées.

\subsection{\textbf{plugin.xml}}
Dans le fichier \textbf{plugin.xml}, il faut juste définire les points d'extensions 
qui existent pour le plugin Coloane, ici nous avons avons décalé deux points
d'extensions: \textit{Imports} et \textit{Exports}. En effet les contributions ne sont obligées d'implementer à la fois 
les fonctions d'importatios et d'exportations.

Voicie, les deux lignes ajoutées dans le fichier \textbf{plugin.xml}:
\begin{verbatim}
<extension-point id="exports" name="Exports" schema="schema/exports.exsd"/>
<extension-point id="imports" name="Imports" schema="schema/imports.exsd"/>
\end{verbatim}

\subsection{\textbf{imports.exsd} et \textbf{exports.exsd}}
Dans les fichiers \textbf{imports.exsd} et \textbf{exports.exsd}, on définie la grammaire des 
points d'extensions. Plus précisement, le nom des attributs, et leur types. Cela permet 
d'indiquer comment utiliser ces points d'extensions. Dans notre cas nous avons trois attributs/
\begin{itemize}
  \item id: C'est l'identifiant du points d'extensions.
  \item name: C'est le nom du nom du point d'extension
  \item class: C'est l'intérface que devrons implements les extensions
\end{itemize}
Noter, qu'il est trés facile, grâce au PDE (Plug-ins Development Environment), de créer ces fichiers, 
\textbf{imports.exsd} et \textbf{exports.exsd}. En effet, il n'y a qu'à remplire des champs, et le PDE, se 
charge de générer automatiquement, les fichiers attendus.

\subsection{MANIFEST.MF}
Dans le fichier \textbf{MANIFEST.MF}, on doit définire les packages, que l'on doit exporter 
pour que les extensions puissent y avoir accés, afin d'implémenter les fonctions 
d'importation et d'exportation.

Voicie, un extrait du fichier \textbf{MANIFEST.MF}, présentant, dans notre 
cas les packages exportés, qui definissent les exceptions que dervons lever les extensions, ainssi que les interfaces 
à implementer, et les methodes à utiliser pour créer un IModelImpl, etc...

\begin{verbatim}
Export-Package: fr.lip6.move.coloane.core.exceptions,
 fr.lip6.move.coloane.core.interfaces,
 fr.lip6.move.coloane.core.main,
 fr.lip6.move.coloane.core.motor.formalism,
 fr.lip6.move.coloane.core.ui.model
\end{verbatim}

\section{Modifications apportées à Coloane}
Nous avons vus approximativement, les modifications apportées à Coloane, pour
déclarer des points d'extensions. A présent, nous allons présentés, les modifications 
au niveaux de l'intérface utilisateur, et les classes ajoutées.

\subsection{L'intérface utilisateur}
\subsubsection{Les items  \textit{"Imports From XXX..."} et \textit{"Exports To XXX..."}}
Comme, il sera dorénavant, possible d'ajouter différents formats pour 
la représentations de Réseau de Petri, il est inimaginable, qu'a chaque format XXX d'ajouter un 
des items \textit{Imports From XXX...} et \textit{Exports To XXX...}, dans le menu \textit{File}, 
cela devindrait trop gros.

Nous avons, donc, optés, pour seulement deux items \textit{Imports From...} et \textit{Exports To...}, 
dans le menu \textit{File}, qui permettent, d'ouvrire une boite de dialogue, et 
demandant à l'utilisateur de choisir un format, et le nom du fichier à importer, ou à exporter.

Pour cela, nous avons déclarer, dans \textbf{plugin.xml}, deux itmes, pour \textit{Imports From...} et 
\textit{Exports To...}.

\begin{verbatim}
<actionSet
            id="fr.lip6.move.coloane.actionSet.file"
            label="%FILEACTIONS_ID"
            visible="true">
         <action
               class="fr.lip6.move.coloane.core.ui.actions.ExportTo"
               icon="resources/icons/export_wiz.gif"
               id="exportTo"
               label="%EXPORT_TO_ITEM"
               menubarPath="file/import.ext"
               style="push">
         </action>
         <action
               class="fr.lip6.move.coloane.core.ui.actions.ImportFrom"
               icon="resources/icons/import_wiz.gif"
               id="importFrom"
               label="%IMPORT_FROM_ITEM"
               menubarPath="file/import.ext"
               style="push">
         </action>
      </actionSet>
\end{verbatim}
On peut voire, que nous avons définie deux classe:
\begin{verbatim}
fr.lip6.move.coloane.core.ui.actions.ExportTo
fr.lip6.move.coloane.core.ui.actions.ImportFrom
\end{verbatim}
ces classes sérvent à definre les actions à effectuer, lorsqu'un utilisateur appuie sur 
l'un de ces items. Il faut noter que ces classes peuvent être considérer comme génerique car 
elles sont capables de créer n'importe quelles instances pour importer ou exporter un format, en utilisant, 
\textbf{ExportToExtension} ou \textbf{ImportFromExtension}, nous y reviendrons, plus tard.

\subsubsection{Les boîtes de dialogues}
La définitions des boîtes de dialogues \textbf{ImportFrom} et \textbf{ExportTo}, sont faites dans
le package: 
\begin{verbatim}
fr.lip6.move.coloane.core.ui.dialogs
\end{verbatim}
Ces deux classes hérites de:
\begin{verbatim}
org.eclipse.jface.dialogs.Dialog;
\end{verbatim}
On peut remarquer, que ces classes font appel à \textbf{ExportToExtension} ou \textbf{ImportFromExtension}, 
pour afficher la liste des formats disponibles, nous y reviendrons plus tard.

\subsection{Les contraintes pour les extensions}
Pour que Coloane, puissent exporter et importer de nouveaux format, il faut que les extensions qui implémentes, 
ces services, réspectent certaines régles. Ces régles sont en faites des intérfaces à implémenter. Ici, nous avons 
deux interfaces:
\begin{verbatim}
fr.lip6.move.coloane.core.interfaces.IExportTo
fr.lip6.move.coloane.core.interfaces.IImportFrom
\end{verbatim}
ces intérfaces permettent à Coloane, de faire appel aux methodes (qui doivent étre commune à toutes les extensions), 
d'importations et d'exportations, quand l'utilisateur le demande, via les itmes correspondant.
\begin{verbatim}
public interface IExportTo {
	public void export(IModelImpl modeleCourant,String filePath) throws ColoaneException;
}

public interface IImportFrom {
	public IModelImpl importFrom(String filePath) throws ColoaneException;
}
\end{verbatim}
ces methodes sont utiliser par les classes:
\begin{verbatim}
fr.lip6.move.coloane.core.ui.actions.ExportTo
fr.lip6.move.coloane.core.ui.actions.ImportFrom
\end{verbatim}

\subsection{Comment savoire quelles extensions sont présentes}
L'une des difficultés, c'est de savoir quelles sont les extensions présentent, 
pour pouvoir afficher leur nom dans la liste déroulante des boîte de dialogues et ainssi pouvoire créé une 
instance pour exporter ou importer le formats voulu par l'utilisateur.

Pour cela nous avons, créé les classes suivnates:
\begin{verbatim}
fr.lip6.move.coloane.core.extensions.ExportToExtension
fr.lip6.move.coloane.core.extensions.ImportFromExtension
\end{verbatim}
Ces classes possedent deux methodes:
\begin{itemize}
  \item \verb?getAllNameExtensionConvert?: cette méthode est utiliser par les boîtes de dialogues \textbf{ImportFromDialog} et \textbf{ExportToDialog}, pour 
afficher la listes des noms des extensions.
  \item \verb?createConvertInstance     ?: cette méthode est utiliser 
par les classes qui \textbf{ImportFrom} et \textbf{ExportTo}, pour créé 
une instance pour exporter ou importer un format.
\end{itemize}

\newpage

\section{Réalisation d'une extension}


\end{document}

